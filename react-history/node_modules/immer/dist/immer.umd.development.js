(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.immer = {}));
}(this, (function (exports) { 'use strict';

	var _ref;

	// Should be no imports here!
	// Some things that should be evaluated before all else...
	// We only want to know if non-polyfilled symbols are available
	var hasSymbol = typeof Symbol !== "undefined" && typeof
	/*#__PURE__*/
	Symbol("x") === "symbol";
	var hasMap = typeof Map !== "undefined";
	var hasSet = typeof Set !== "undefined";
	var hasProxies = typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined";
	/**
	 * The sentinel value returned by producers to replace the draft with undefined.
	 */

	var NOTHING = hasSymbol ?
	/*#__PURE__*/
	Symbol.for("immer-nothing") : (_ref = {}, _ref["immer-nothing"] = true, _ref);
	/**
	 * To let Immer treat your class instances as plain immutable objects
	 * (albeit with a custom prototype), you must define either an instance property
	 * or a static property on each of your custom classes.
	 *
	 * Otherwise, your class instance will never be drafted, which means it won't be
	 * safe to mutate in a produce callback.
	 */

	var DRAFTABLE = hasSymbol ?
	/*#__PURE__*/
	Symbol.for("immer-draftable") : "__$immer_draftable";
	var DRAFT_STATE = hasSymbol ?
	/*#__PURE__*/
	Symbol.for("immer-state") : "__$immer_state"; // Even a polyfilled Symbol might provide Symbol.iterator

	var iteratorSymbol = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";

	var errors = {
	  0: "Illegal state",
	  1: "Immer drafts cannot have computed properties",
	  2: "This object has been frozen and should not be mutated",
	  3: function _(data) {
	    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
	  },
	  4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
	  5: "Immer forbids circular references",
	  6: "The first or second argument to `produce` must be a function",
	  7: "The third argument to `produce` must be a function or undefined",
	  8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
	  9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
	  10: "The given draft is already finalized",
	  11: "Object.defineProperty() cannot be used on an Immer draft",
	  12: "Object.setPrototypeOf() cannot be used on an Immer draft",
	  13: "Immer only supports deleting array indices",
	  14: "Immer only supports setting array indices and the 'length' property",
	  15: function _(path) {
	    return "Cannot apply patch, path doesn't resolve: " + path;
	  },
	  16: 'Sets cannot have "replace" patches.',
	  17: function _(op) {
	    return "Unsupported patch operation: " + op;
	  },
	  18: function _(plugin) {
	    return "The plugin for '" + plugin + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + plugin + "()` when initializing your application.";
	  },
	  20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
	  21: function _(thing) {
	    return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + thing + "'";
	  },
	  22: function _(thing) {
	    return "'current' expects a draft, got: " + thing;
	  },
	  23: function _(thing) {
	    return "'original' expects a draft, got: " + thing;
	  },
	  24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
	};
	function die(error) {
	  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }

	  {
	    var e = errors[error];
	    var msg = !e ? "unknown error nr: " + error : typeof e === "function" ? e.apply(null, args) : e;
	    throw new Error("[Immer] " + msg);
	  }
	}

	var ArchtypeObject = 0;
	var ArchtypeArray = 1;
	var ArchtypeMap = 2;
	var ArchtypeSet = 3;
	var ProxyTypeProxyObject = 0;
	var ProxyTypeProxyArray = 1;
	var ProxyTypeES5Object = 4;
	var ProxyTypeES5Array = 5;
	var ProxyTypeMap = 2;
	var ProxyTypeSet = 3;

	/** Returns true if the given value is an Immer draft */

	/*#__PURE__*/

	function isDraft(value) {
	  return !!value && !!value[DRAFT_STATE];
	}
	/** Returns true if the given value can be drafted by Immer */

	/*#__PURE__*/

	function isDraftable(value) {
	  if (!value) return false;
	  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);
	}
	/*#__PURE__*/

	function isPlainObject(value) {
	  if (!value || typeof value !== "object") return false;
	  var proto = Object.getPrototypeOf(value);
	  return !proto || proto === Object.prototype;
	}
	function original(value) {
	  if (!isDraft(value)) die(23, value);
	  return value[DRAFT_STATE].base_;
	}
	/*#__PURE__*/

	var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function (obj) {
	  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
	} :
	/* istanbul ignore next */
	Object.getOwnPropertyNames;
	var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
	  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
	  var res = {};
	  ownKeys(target).forEach(function (key) {
	    res[key] = Object.getOwnPropertyDescriptor(target, key);
	  });
	  return res;
	};
	function each(obj, iter, enumerableOnly) {
	  if (enumerableOnly === void 0) {
	    enumerableOnly = false;
	  }

	  if (getArchtype(obj) === ArchtypeObject) {
	    (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function (key) {
	      if (!enumerableOnly || typeof key !== "symbol") iter(key, obj[key], obj);
	    });
	  } else {
	    obj.forEach(function (entry, index) {
	      return iter(index, entry, obj);
	    });
	  }
	}
	/*#__PURE__*/

	function getArchtype(thing) {
	  /* istanbul ignore next */
	  var state = thing[DRAFT_STATE];
	  return state ? state.type_ > 3 ? state.type_ - 4 // cause Object and Array map back from 4 and 5
	  : state.type_ // others are the same
	  : Array.isArray(thing) ? ArchtypeArray : isMap(thing) ? ArchtypeMap : isSet(thing) ? ArchtypeSet : ArchtypeObject;
	}
	/*#__PURE__*/

	function has(thing, prop) {
	  return getArchtype(thing) === ArchtypeMap ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
	}
	/*#__PURE__*/

	function get(thing, prop) {
	  // @ts-ignore
	  return getArchtype(thing) === ArchtypeMap ? thing.get(prop) : thing[prop];
	}
	/*#__PURE__*/

	function set(thing, propOrOldValue, value) {
	  var t = getArchtype(thing);
	  if (t === ArchtypeMap) thing.set(propOrOldValue, value);else if (t === ArchtypeSet) {
	    thing.delete(propOrOldValue);
	    thing.add(value);
	  } else thing[propOrOldValue] = value;
	}
	/*#__PURE__*/

	function is(x, y) {
	  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
	  if (x === y) {
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    return x !== x && y !== y;
	  }
	}
	/*#__PURE__*/

	function isMap(target) {
	  return hasMap && target instanceof Map;
	}
	/*#__PURE__*/

	function isSet(target) {
	  return hasSet && target instanceof Set;
	}
	/*#__PURE__*/

	function latest(state) {
	  return state.copy_ || state.base_;
	}
	/*#__PURE__*/

	function shallowCopy(base) {
	  if (Array.isArray(base)) return Array.prototype.slice.call(base);
	  var descriptors = getOwnPropertyDescriptors(base);
	  delete descriptors[DRAFT_STATE];
	  var keys = ownKeys(descriptors);

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var desc = descriptors[key];

	    if (desc.writable === false) {
	      desc.writabl